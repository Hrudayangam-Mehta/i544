function makeGetCellHandler(app: Express.Application) {
  return async function (req: Express.Request, res: Express.Response) {
    try {
      const { ssName, cellId } = req.params;
      const result = await app.locals.ssServices.getCell(ssName, cellId);
      if (!result.isOk) throw result;
      res.json(selfResult(req, result.val));
    } catch (err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}

function makeSetCellHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;
      const cellId = req.params.cellId;
      const { expr, result } = req.query;

      // Validate query parameters
      if (!expr || !result) {
        throw {
          status: STATUS.BAD_REQUEST,
          errors: [{ options: { code: 'BAD_REQ' }, message: 'expr and result query parameters are required' }],
        };
      }

      const setCellResult = await app.locals.ssServices.setCell(ssName, cellId, { expr, result });
      if (!setCellResult.isOk) {
        throw setCellResult;
      }

      const successEnvelope = selfResult(req, setCellResult.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}


function makeCopyCellHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;
      const cellId = req.params.cellId;
      const srcCellId = req.query.srcCellId;

      // Validate query parameters
      if (!srcCellId) {
        throw {
          status: STATUS.BAD_REQUEST,
          errors: [{ options: { code: 'BAD_REQ' }, message: 'srcCellId query parameter is required' }],
        };
      }

      const result = await app.locals.ssServices.copyCell(ssName, cellId, srcCellId);
      if (!result.isOk) {
        throw result;
      }
      
      const successEnvelope = selfResult(req, result.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}

function makeDeleteCellHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;
      const cellId = req.params.cellId;
      const result = await app.locals.ssServices.deleteCell(ssName, cellId);
      if (!result.isOk) {
        throw result;
      }
      
      const successEnvelope = selfResult(req, result.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}

function makeClearSpreadsheetHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;
      const result = await app.locals.ssServices.clearSpreadsheet(ssName);
      if (!result.isOk) {
        throw result;
      }
      
      const successEnvelope = selfResult(req, result.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}

function makeLoadSpreadsheetHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;

      // Validate request body
      if (!Array.isArray(req.body)) {
        throw {
          status: STATUS.BAD_REQUEST,
          errors: [{ options: { code: 'INVALID_BODY' }, message: 'Request body must be an array' }],
        };
      }

      const result = await app.locals.ssServices.loadSpreadsheet(ssName, req.body);
      if (!result.isOk) {
        throw result;
      }
      
      const successEnvelope = selfResult(req, result.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}

function makeGetSpreadsheetHandler(app: Express.Application) {
  return async function(req: Express.Request, res: Express.Response) {
    try {
      const ssName = req.params.ssName;
      const result = await app.locals.ssServices.getSpreadsheet(ssName);
      if (!result.isOk) {
        throw result;
      }
      
      const successEnvelope = selfResult(req, result.val);
      res.json(successEnvelope);
    } catch(err) {
      const mapped = mapResultErrors(err);
      res.status(mapped.status).json(mapped);
    }
  };
}


according to these hints:
ll request and response bodies for the web services must use type JSON. Responses are always enclosed within success or error envelopes as per the following typescript definitions (in response-envelope.ts).

/** a link contains a href URL and HTTP method */
type HrefMethod = {
  href: string,
  method: string
};

/** a self link using rel self */
export type SelfLink = {
  self: HrefMethod,
};

/** a result of type T which has a links containing a self-link */
type LinkedResult<T> = {
  links: SelfLink,
  result: T,
};

/** a response envelope always has an isOk and HTTP status */
type Envelope = {
  isOk: boolean,
  status: number,
};

/** an envelope for a successful response */
export type SuccessEnvelope<T> = Envelope & LinkedResult<T> & {
  isOk: true,
};

/** an envelope for a failed response */
export type ErrorEnvelope = Envelope & {
  isOk: false,
  errors: { message: string, options?: { [key:string]: string } }[],
};
Assuming that your server is set up to run with all URLs rooted at BASE, it will need to implement the following web services:

Get-Cell: GET BASE/SS_NAME/CELL_ID
This service should set the result of the success envelope to a { expr: string, value: number } representing the state of cell CELL_ID in spreadsheet SS_NAME.

Set-Cell: PATCH BASE/SS_NAME/CELL_ID?expr=EXPR
This service should update the expr for cell CELL_ID in spreadsheet SS_NAME to EXPR and set the result of the success envelope to an object { [cellId: string]: number } of all affected cells.

Copy-Cell: PATCH BASE/SS_NAME/CELL_ID?srcCellId=SRC_CELL_ID
This service should copy the expr from cell SRC_CELL_ID to cell CELL_ID in spreadsheet SS_NAME to EXPR and set the result of the success envelope to an object { [cellId: string]: number } of all affected cells.

Delete-Cell: DELETE BASE/SS_NAME/CELL_ID
This service should delete cell CELL_ID in spreadsheet SS_NAME and set the result of the success envelope to an object { [cellId: string]: number } of all affected cells.

Clear-Spreadsheet: DELETE BASE/SS_NAME
Clear the contents of spreadsheet SS_NAME. The result in the success envelope should be undefined.

Load-Spreadsheet: PUT BASE/SS_NAME
Set the contents of spreadsheet SS_NAME to the JSON body of the request which should be an array of [ string, string ] pairs representing the [ CELL_ID, EXPR ]. The result in the success envelope should be undefined.

Get-Spreadsheet: GET BASE/SS_NAME
This service should set the result of the success envelope to an array of [ string, string ] pairs representing the [ CELL_ID, EXPR ] of all non-deleted cells in spreadsheet SS_NAME.

Note that both the Set-Cell and Copy-Cell use a PATCH method on the same URL; they differ only in their query parameters. The former uses an expr query parameter, whereas the latter uses a srcCellId query parameter.

All success envelopes should have an HTTP status code 200 OK. If any of the above services encounters an error, then the service should return a suitable error envelope. Error responses should contain a suitable HTTP status (often BAD REQUEST 400).

make the function : code for the makeGetCellHandler, makeSetCellHandler, makeCopyCellHandler, makeDeleteCellHandler, makeClearSpreadsheetHandler, makeLoadSpreadsheetHandler, and makeGetSpreadsheetHandler